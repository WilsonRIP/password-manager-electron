-- Create the passwords table
CREATE TABLE public.passwords (
  -- Use UUID for primary key, auto-generated by default
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- Clerk user ID
  user_id TEXT NOT NULL DEFAULT requesting_user_id(),
  
  -- Timestamps managed by Supabase/Postgres
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  
  -- Encryption related fields (nullable if desired, but TEXT should be fine)
  salt TEXT NOT NULL,
  title_iv TEXT NOT NULL,
  title_ciphertext TEXT NOT NULL,
  username_iv TEXT NOT NULL,
  username_ciphertext TEXT NOT NULL,
  password_iv TEXT NOT NULL,
  password_ciphertext TEXT NOT NULL,
  url_iv TEXT, -- URL might be optional, allow NULL? Assuming NOT NULL based on form logic
  url_ciphertext TEXT -- Assuming NOT NULL based on form logic
  -- Consider adding NOT NULL constraints if appropriate for iv/ciphertext fields
);

-- Enable Row Level Security
ALTER TABLE public.passwords ENABLE ROW LEVEL SECURITY;

-- Add policy for Row Level Security
-- Allows users to manage only their own passwords
CREATE POLICY "Allow individual access" ON public.passwords
  FOR ALL
  USING (requesting_user_id() = user_id)
  WITH CHECK (requesting_user_id() = user_id);

-- Automatically update updated_at timestamp on changes
CREATE OR REPLACE FUNCTION public.update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_passwords_updated_at
BEFORE UPDATE ON public.passwords
FOR EACH ROW
EXECUTE FUNCTION public.update_updated_at_column();

-- Optional: Add indexes for frequently queried/sorted columns if needed
-- CREATE INDEX idx_passwords_created_at ON public.passwords (created_at);
-- CREATE INDEX idx_passwords_updated_at ON public.passwords (updated_at);